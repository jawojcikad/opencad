/**
 * GLSL shader sources for the WebGL2 renderer.
 *
 * All shaders use GLSL ES 3.00 (`#version 300 es`).
 */
export declare const basicVertexSource = "#version 300 es\nprecision highp float;\n\nuniform mat3 u_viewProjection;\n\nin vec2 a_position;\n\nvoid main() {\n  vec3 transformed = u_viewProjection * vec3(a_position, 1.0);\n  gl_Position = vec4(transformed.xy, 0.0, 1.0);\n}\n";
export declare const solidColorFragmentSource = "#version 300 es\nprecision highp float;\n\nuniform vec4 u_color;\nout vec4 fragColor;\n\nvoid main() {\n  fragColor = u_color;\n}\n";
export declare const circleVertexSource = "#version 300 es\nprecision highp float;\n\nuniform mat3 u_viewProjection;\n\n// Per-vertex unit quad (-1 \u2026 1)\nin vec2 a_position;\n\n// Per-instance\nin vec2 a_center;\nin float a_radius;\n\nout vec2 v_uv;\n\nvoid main() {\n  v_uv = a_position;  // -1 \u2026 1\n\n  vec2 worldPos = a_center + a_position * a_radius;\n  vec3 transformed = u_viewProjection * vec3(worldPos, 1.0);\n  gl_Position = vec4(transformed.xy, 0.0, 1.0);\n}\n";
export declare const circleFragmentSource = "#version 300 es\nprecision highp float;\n\nuniform vec4 u_color;\n\nin vec2 v_uv;\nout vec4 fragColor;\n\nvoid main() {\n  float dist = length(v_uv);\n\n  // Smooth anti-aliased edge.  fwidth gives the rate of change of\n  // dist across the fragment, giving us a 1-pixel-wide blend.\n  float edge = fwidth(dist);\n  float alpha = 1.0 - smoothstep(1.0 - edge, 1.0 + edge, dist);\n\n  if (alpha < 0.001) discard;\n\n  fragColor = vec4(u_color.rgb, u_color.a * alpha);\n}\n";
export declare const gridVertexSource = "#version 300 es\nprecision highp float;\n\nuniform mat3 u_viewProjection;\n\nin vec2 a_position;\nout vec2 v_worldPos;\n\nvoid main() {\n  v_worldPos = a_position;\n  vec3 transformed = u_viewProjection * vec3(a_position, 1.0);\n  gl_Position = vec4(transformed.xy, 0.0, 1.0);\n}\n";
export declare const gridFragmentSource = "#version 300 es\nprecision highp float;\n\nuniform float u_majorSpacing;\nuniform float u_minorSpacing;\nuniform vec4 u_majorColor;\nuniform vec4 u_minorColor;\n\nin vec2 v_worldPos;\nout vec4 fragColor;\n\nfloat gridLine(float coord, float spacing) {\n  float d   = abs(fract(coord / spacing + 0.5) - 0.5) * spacing;\n  float fw  = fwidth(coord);\n  return 1.0 - smoothstep(0.0, fw * 1.5, d);\n}\n\nvoid main() {\n  float major = max(\n    gridLine(v_worldPos.x, u_majorSpacing),\n    gridLine(v_worldPos.y, u_majorSpacing)\n  );\n  float minor = max(\n    gridLine(v_worldPos.x, u_minorSpacing),\n    gridLine(v_worldPos.y, u_minorSpacing)\n  );\n\n  vec4 color = mix(u_minorColor, u_majorColor, major) * max(major, minor);\n  if (color.a < 0.001) discard;\n  fragColor = color;\n}\n";
//# sourceMappingURL=shaders.d.ts.map